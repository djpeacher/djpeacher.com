<!doctype html><html><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="My notes from #djangocon ðŸ¦€ day 3."><meta name=keywords content><link rel=canonical href=http://www.djpeacher.com/posts/djangocon-us-22-day-3/><link rel=stylesheet href=https://cdn.simplecss.org/simple.min.css><link rel=stylesheet href=/css/simple-plus.css><link rel=stylesheet href=/css/custom.css><link rel=icon type=image/png sizes=32x32 href=/img/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/img/favicon-16x16.png><title>DjangoCon US 2022: Day 3 | Jonathan Peacher</title><style>:root{--bg:#fff;--accent-bg:#f5f5f5;--text:#212121;--text-light:#585858;--border:#d8dae1;--accent:#212121;--code:#d81b60;--preformatted:#444;--marked:#ffdd33;--disabled:#efefef}@media(prefers-color-scheme:dark){:root{--bg:#212121;--accent-bg:#2b2b2b;--text:#dcdcdc;--text-light:#ababab;--border:#666;--accent:#809fff;--code:#f06292;--preformatted:#ccc;--marked:#ffdd33;--disabled:#111}}</style><link rel=stylesheet href=https://cdn.jsdelivr.net/gh/SebastianAigner/twemoji-amazing@1.0.0/twemoji-amazing.css><link rel=alternate type=application/rss+xml href=/posts/index.xml title="Jonathan Peacher"><script src=https://cdn.usefathom.com/script.js data-site=KFUFSJGY defer></script></head><body><header><nav><a href=/>Home</a>
<a href=/about/>About</a>
<a href=/now/>Now</a>
<a href=/code/>Code</a>
<a href=https://twitter.com/_djpeacher target=_blank>Twitter</a></nav><h1>DjangoCon US 2022: Day 3</h1><p>My notes from #djangocon ðŸ¦€ day 3.</p><time datetime=221019>221019</time></header><main><h2 id=async-django-the-practical-guide-youve-been-awaiting-forhttps2022djangoconustalksasync-django-the-practical-guide-you-ve><a href=https://2022.djangocon.us/talks/async-django-the-practical-guide-you-ve/>Async Django: The practical guide you&rsquo;ve been awaiting for.</a></h2><ul><li><p>Async is exciting, but be aware that using async will make your application more complex.</p></li><li><p><code>import asyncio</code>: Python&rsquo;s implementation of an async runtime that Django uses.</p><pre tabindex=0><code>import asyncio
async def foo():
  ...
  await bar()

async def main():
  tasks = [asyncio.create_task(foo()) for range(5)]
  # Important! Wait for all tasks to complete.
  await asyncio.gather(*tasks)

asyncio.run(main())
</code></pre></li><li><p>Can you use this for background tasks?</p><ul><li>Kind off&mldr;if it fails, there is no built-in statuses, retires, or error handling.</li><li>It depends&mldr;on how you are running Django (WSGI or ASGI). With WSGI, hitting an async view spins up an event loop, but will disappear when then view exits (like the example above).</li></ul></li><li><p>Aggregate Views (what you did before GraphQL):</p><pre tabindex=0><code>import httpx
import asyncio

async def aggregate_view(): # pseudo code
  async with httpx.AsyncClient() as client:
    response_a, response_b = asyncio.gather(
      client.get(view_a_url),
      client.get(view_b_url),
    )
  return JsonResponse({
    &#39;response_a&#39;: response_a.json(),
    &#39;response_b&#39;: response_b.json(),
  })
</code></pre></li><li><p>Chat App (four ways):</p><ul><li>Polling (HTMX): Simple, but doesn&rsquo;t scale, isn&rsquo;t responsive, and can lead to self DDOS.</li><li>Long Polling (HTMX + Channels): Responsiveness, but creates a lot connections.</li><li>Server-Sent Events (HTMX + Channels): Better, keeps the connection open.</li><li>WebSockets (HTMX + Channels): Also keeps the connection open, but allows two-way communication.</li></ul></li></ul><h2 id=why-large-django-projects-need-a-data-prefetching-layerhttps2022djangoconustalkswhy-large-django-projects-need-a-data><a href=https://2022.djangocon.us/talks/why-large-django-projects-need-a-data/>Why large Django projects need a data (prefetching) layer</a></h2><ul><li><p>&ldquo;DRY isn&rsquo;t helpful if you need to be careful.&rdquo;</p></li><li><p>Django REST Framework loves DRY, but has high change amplification as a side effect.</p></li><li><p>Change Amplification: The expected number of places in the codebase that needs to be modified during an atomic change to the software.</p></li><li><p>An example of this in DRF is needing to prefetch in serializers.</p><pre tabindex=0><code>class MovieSerializer(ModelSerializer):
  # data that requires prefetching

# You have to remeber to prefetch for each view using MovieSerializer.
class MovieListView(ListAPIView):
  queryset = Movie.objects.prefetch_related(&#34;directors&#34;)
  serializer_class = MovieSerializer

class MovieDetailView(ListAPIView):
  queryset = Movie.objects.prefetch_related(&#34;directors&#34;)
  serializer_class = MovieSerializer
</code></pre></li><li><p>You could do one of two things to combat this:</p><ol><li>Use non-DRF serializers that are very <strong>explicit</strong> about prefetching.</li></ol><ul><li><code>django-virtual-models</code>.</li></ul><ol start=2><li>Or keep DRF, but:</li></ol><ul><li>Warn about missing prefetches for each serializer.</li><li>Automatically run necessary prefetches.</li><li>Automatically prevent unnecessary ones.</li><li>Keep serializer nesting support.</li><li>Keep <code>SerializerMethodField</code> support.</li></ul></li><li><p>TLDR: Use tools to be <strong>explicit</strong> about the data you expect from the DB. Otherwise you&rsquo;ll suffer from performance regressions and your read logic will break frequently.</p></li></ul><h2 id=a-pythonic-full-text-searchhttps2022djangoconustalksa-pythonic-full-text-search><a href=https://2022.djangocon.us/talks/a-pythonic-full-text-search/>A pythonic full-text search</a></h2><ul><li>PostgreSQL added full text search in 2008.</li><li>Django added <a href=https://docs.djangoproject.com/en/4.1/ref/contrib/postgres/search/>full text search</a> in 2016.</li><li>Paolo has a <a href=https://www.paulox.net/2017/12/22/full-text-search-in-django-with-postgresql/>great article</a> outlining the various search features.</li></ul><h2 id=home-on-the-range-with-django---getting-comfortable-with-ranges-and-range-fieldshttps2022djangoconustalkshome-on-the-range-with-django-getting><a href=https://2022.djangocon.us/talks/home-on-the-range-with-django-getting/>Home on the range with Django - getting comfortable with ranges and range fields</a></h2><ul><li>Ranges are everywhere!</li><li>Support for <a href=https://docs.djangoproject.com/en/4.1/ref/contrib/postgres/fields/#range-fields>ranges</a> was added for PostgreSQL Django in 2015.</li><li>The typical approach is to us &ldquo;start&rdquo; and &ldquo;stop&rdquo; fields, but that gets complicated fast.<ul><li>The DB doesn&rsquo;t know these two fields are related.</li><li>You have to manually add bounding/validation/constraint logic.</li><li>Queries can get weird/complicated.</li></ul></li><li>Ranges fix all this!<ul><li>1 field that stores lower, upper, and boundary information.</li><li>Automatically validates/constrains values.</li><li>Easy/Intuitive queries.</li></ul></li><li>Ranges (Math):<ul><li>Ranges = Intervals, Inclusive = Closed, Exclusive = Open</li><li>(exclusive, exclusive) - (1, 3) - 2</li><li>[inclusive, exclusive) - [1, 3) - 1, 2 <code>The default for Django ranges!</code></li><li>(exclusive, inclusive] - (1, 3] - 2, 3</li><li>[inclusive, inclusive] - [1, 3] - 1, 2, 3</li></ul></li><li>There are lots of very useful query filters!<ul><li><code>__overlap</code>, <code>__contains</code>, <code>__adjacent_to</code>, <code>__fully_lt/gt</code>, etc.</li></ul></li><li>Django supports a number of different value types via <code>pysycopg2.extra</code>.<ul><li>You can also create custom types! Example: IP ranges!</li></ul></li><li>Pitfalls<ul><li>Limited Django Admin support.</li><li>You have to use <code>Cast</code> when using <code>F()</code>.</li><li>You have to use <code>Lower</code> and <code>Upper</code> database functions to access values.</li></ul></li><li>Resources<ul><li><code>psycopg2.extras</code></li><li><code>django-range-merge</code></li><li><code>django-generate-series</code></li></ul></li></ul><a class="button replyButton" href="mailto: reply@djpeacher.com?subject=Reply to 'DjangoCon%20US%202022%3a%20Day%203'">Reply via email</a></main><footer><p>CC 2022 Jonathan Peacher. <a href=http://creativecommons.org/licenses/by-sa/4.0/>Some rights reserved.</a></p></footer></body></html>