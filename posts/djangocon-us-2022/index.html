<!doctype html><html><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="Day 1 The Django Admin Is Your Oyster: Let’s Extend Its Functionality Documenting Django Code in 2022 You Don&amp;rsquo;t Need Containers to Run Django in Production Herding your database queries: diagnosing, improving and guarding performance of DB interactions in your Django apps The Django Jigsaw Puzzle: Aligning All the Pieces Nurturing a &amp;ldquo;Legacy&amp;rdquo; Codebase Day 2 Keeping track of architectural-ish decisions in a sustainable way Django Migrations: Pitfalls and Solutions Django Through the Years Just enough ops for developers Your First Deployment Shouldn&amp;rsquo;t Be So Hard!"><meta name=keywords content><link rel=canonical href=https://www.djpeacher.com/posts/djangocon-us-2022/><link rel=stylesheet href=https://cdn.simplecss.org/simple.min.css><link rel=stylesheet href=/css/simple-plus.css><link rel=stylesheet href=/css/custom.css><link rel=icon type=image/png sizes=32x32 href=/img/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/img/favicon-16x16.png><title>DjangoCon US 2022 | Jonathan Peacher</title><style>:root{--bg:#fff;--accent-bg:#f5f5f5;--text:#212121;--text-light:#585858;--border:#d8dae1;--accent:#212121;--code:#d81b60;--preformatted:#444;--marked:#ffdd33;--disabled:#efefef}@media(prefers-color-scheme:dark){:root{--bg:#212121;--accent-bg:#2b2b2b;--text:#dcdcdc;--text-light:#ababab;--border:#666;--accent:#809fff;--code:#f06292;--preformatted:#ccc;--marked:#ffdd33;--disabled:#111}}</style><link rel=stylesheet href=https://cdn.jsdelivr.net/gh/SebastianAigner/twemoji-amazing@1.0.0/twemoji-amazing.css><link rel=alternate type=application/rss+xml href=/posts/index.xml title="Jonathan Peacher"><link rel=me href=https://fosstodon.org/@djpeacher><script src=https://cdn.usefathom.com/script.js data-site=KFUFSJGY defer></script></head><body><main><a href=/ style=text-decoration:none>Jonathan Peacher</a><h1 style=margin-bottom:.5rem>DjangoCon US 2022</h1><div style=margin-bottom:1.5rem><time datetime=221019>221019</time></div><nav id=TableOfContents><ul><li><a href=#day-1>Day 1</a><ul><li><a href=#the-django-admin-is-your-oyster-lets-extend-its-functionality>The Django Admin Is Your Oyster: Let’s Extend Its Functionality</a></li><li><a href=#documenting-django-code-in-2022>Documenting Django Code in 2022</a></li><li><a href=#you-dont-need-containers-to-run-django-in-production>You Don&rsquo;t Need Containers to Run Django in Production</a></li><li><a href=#herding-your-database-queries-diagnosing-improving-and-guarding-performance-of-db-interactions-in-your-django-apps>Herding your database queries: diagnosing, improving and guarding performance of DB interactions in your Django apps</a></li><li><a href=#the-django-jigsaw-puzzle-aligning-all-the-pieces>The Django Jigsaw Puzzle: Aligning All the Pieces</a></li><li><a href=#nurturing-a-legacy-codebase>Nurturing a &ldquo;Legacy&rdquo; Codebase</a></li></ul></li><li><a href=#day-2>Day 2</a><ul><li><a href=#keeping-track-of-architectural-ish-decisions-in-a-sustainable-way>Keeping track of architectural-ish decisions in a sustainable way</a></li><li><a href=#django-migrations-pitfalls-and-solutions>Django Migrations: Pitfalls and Solutions</a></li><li><a href=#django-through-the-years>Django Through the Years</a></li><li><a href=#just-enough-ops-for-developers>Just enough ops for developers</a></li><li><a href=#your-first-deployment-shouldnt-be-so-hard>Your First Deployment Shouldn&rsquo;t Be So Hard!</a></li></ul></li><li><a href=#day-3>Day 3</a><ul><li><a href=#async-django-the-practical-guide-youve-been-awaiting-for>Async Django: The practical guide you&rsquo;ve been awaiting for.</a></li><li><a href=#why-large-django-projects-need-a-data-prefetching-layer>Why large Django projects need a data (prefetching) layer</a></li><li><a href=#a-pythonic-full-text-search>A pythonic full-text search</a></li><li><a href=#home-on-the-range-with-django---getting-comfortable-with-ranges-and-range-fields>Home on the range with Django - getting comfortable with ranges and range fields</a></li></ul></li></ul></nav><h2 id=day-1>Day 1</h2><h3 id=the-django-admin-is-your-oyster-lets-extend-its-functionality>The Django Admin Is Your Oyster: Let’s Extend Its Functionality</h3><ul><li><p>Don&rsquo;t make it easy for attackers to find your admin page&mldr;don&rsquo;t use <code>/admin</code>.</p></li><li><p>Override <code>ModelAdmin.get_search_results</code> to speed up searching.</p></li><li><p>Remember to use <code>prefetch_related</code> and <code>select_related</code> to reduce DB queries.</p></li><li><p>Add optional checkboxes to change forms to kickoff extra functions when saved.</p><ul><li>You can also dynamically set help text for better UX.</li></ul></li><li><p>You can use multiple databases in a single admin.</p><pre tabindex=0><code># Migrate
$ python manage.py --database=sandbox

# settings.py
DATABASES = {
  &#39;default&#39;: {...},
  &#39;sandbox&#39;: {...}
}

# utils.py
class SandboxAdminModel(admin.ModelAdmin):
  using = &#39;sandbox&#39;

  def save_model(self, request, obj, form, change):
      obj.save(using=self.using)

  def delete_model(self, request, obj):
      obj.delete(using=self.using)

  def get_queryset(self, request):
      return super().get_queryset(request).using(self.using)

# admin.py
@admin.register(MySandboxModel)
class MySandboxModelAdmin(SandboxModelAdmin):
  ...
</code></pre></li><li><p>Extend <code>change_form.html</code> to add help text for the whole model, not just fields.</p><pre tabindex=0><code># change_form.html
{% extends &#34;admin/change_form.html&#34; %}

{% block form_top %}
  {{ original.admin_help_text }}
{% endblock %}

# models.py
class MyModel(models.Model):
  admin_help_text = &#34;...&#34;
</code></pre></li><li><p>Create custom actions for bulk changes.</p><pre tabindex=0><code># admin.py
def increase_msrp_by_8_perc(modeladmin, request, queryset):
  ...

@admin.register(Car)
class CarAdmin(admin.ModelAdmin):
  actions = [increase_msrp_by_8_perc]
</code></pre></li></ul><h3 id=documenting-django-code-in-2022>Documenting Django Code in 2022</h3><ul><li><a href=https://diataxis.fr>https://diataxis.fr</a>: A framework for authoring technical documentation.</li></ul><h3 id=you-dont-need-containers-to-run-django-in-production>You Don&rsquo;t Need Containers to Run Django in Production</h3><ul><li>When <strong>should</strong> you use containers? When you have&mldr;<ul><li>Thousands of programmers.</li><li>Millions of users.</li><li>Billions in valuation.</li></ul></li><li>There is a lot of FOMO around containers. For example, reproducibility is a big selling point for containers, but generally, this benefit is rarely taken advantage of.</li><li>Some downsides of using containers are added <a href=https://landscape.cncf.io>complexity</a> and cost.</li><li>What do we want in production?<ul><li>Secure environment.</li><li>Protection against malicious users.</li><li>Don&rsquo;t want to wake up in the middle of the night.</li><li>Seamless code updates.</li></ul></li><li>Web Server (WSGI vs ASGI):<ul><li>WSGI is 20 years old&mldr;and it shows.<ul><li>Limited concurrency.</li><li>Graphic: <em>Showed that as clients scale with <code>gunicorn</code>, response time gets worse. The graph represented a BEST case scenario.</em></li></ul></li><li>ASGI is 5 years old&mldr;and it shows.<ul><li>Unlimited concurrency (ignoring memory).</li><li>Graphic: <em>Showed that as clients scale with <code>uvicorn</code>, response time gets worse. The graph represented a WORST case scenario.</em></li></ul></li></ul></li><li>Reverse Proxy (nginx):<ul><li>Can help limit concurrency as needed.</li><li>nginx can handle 20 million RPM on a 8 core VM.</li><li>Caddy is a new/easier alternative, but nginx is tried and tested.</li></ul></li><li>Process Monitor (SystemD)</li><li>Deployment (Git Deploy Config)</li><li>Bonus Tip: Use software that offers LTS.</li></ul><h3 id=herding-your-database-queries-diagnosing-improving-and-guarding-performance-of-db-interactions-in-your-django-apps>Herding your database queries: diagnosing, improving and guarding performance of DB interactions in your Django apps</h3><ul><li><p><a href=https://engineering.pathai.com/herding-your-database-queries-in-django>Blog Post</a></p></li><li><p>Tools like <code>django-debug-toolbar</code> and <code>django-silk</code> are great for diagnosing rogue queries, but there can be cases where these tools are not going to help directly (e.g. with a js frontend).</p></li><li><p>To solve this, they rolled their own <a href=https://github.com/Path-AI/django-request-stats-example/blob/main/req_stats/middleware.py>custom middleware</a> to analyze queries per request and output the result to the terminal.</p><pre tabindex=0><code>Received request GET /library/books/, status 200, db_query_count=29, db_query_time_ms=136.421, duration_ms=192.56
</code></pre></li><li><p>After you optimize your queries, you can protect yourself from regression with unit tests by taking advantage of <a href=https://pytest-django.readthedocs.io/en/latest/helpers.html#django-assert-max-num-queries>django_assert_max_num_queries</a>.</p></li><li><p>You can also use <a href=https://coverage.readthedocs.io/en/6.4.3/contexts.html>coverage context</a> to check new endpoints that are created and don&rsquo;t have unit tests.</p></li></ul><h3 id=the-django-jigsaw-puzzle-aligning-all-the-pieces>The Django Jigsaw Puzzle: Aligning All the Pieces</h3><ul><li>(other) MVC == MVT (django)<ul><li>Model == Model</li><li>View == Template</li><li>Controller == View</li></ul></li><li>The Django Admin is great, but if your <code>admin.py</code> is growing past 20 lines, you might be relying on it too much.</li><li><code>django-extensions</code>: One of the things it does is auto import models in the django shell.</li><li>Don&rsquo;t use <code>/admin</code>!</li></ul><pre tabindex=0><code>                                        WSGI Server
                                        ┌────────────────────────────────────────────────┐
                                        │ Middlware                                      │
                                        │ ┌────────────────────────────────────────────┐ │
                                        │ │ Django app                                 │ │
         HTTP request                   │ │ ┌────────────────────────────────────────┐ │ │
        ─────────────► ┌──────────┐ ──► │ │ │ ┌────────┐     ┌─────┐     ┌──────┐    │ │ │   ┌─────────┐
Browser                │Web Server│     │ │ │ │URL conf│ ──► │     │ ─── │Models│ ───┼─┼─┼── │Databases│
        ◄───────────── └──────────┘ ◄── │ │ │ └────────┘     │     │     └──────┘    │ │ │   └─────────┘
         HTTP response      ▲           │ │ │                │Views│                 │ │ │
                            │           │ │ │                │     │     ┌─────────┐ │ │ │
                            ▼           │ │ │                │     │ ─── │Templates│ │ │ │
                         ┌──────┐       │ │ │                └─────┘     └─────────┘ │ │ │
                         │ File │       │ │ └────────────────────────────────────────┘ │ │
                         │System│       │ └────────────────────────────────────────────┘ │
                         └──────┘       └────────────────────────────────────────────────┘
</code></pre><h3 id=nurturing-a-legacy-codebase>Nurturing a &ldquo;Legacy&rdquo; Codebase</h3><ul><li>What is a &ldquo;legacy&rdquo; codebase?<ul><li>Code with, potentially forgotten, history.</li><li>Code that follow outdated conventions.</li><li>Usually still running in production.</li></ul></li><li>Should you evolve or rebuild? Ask yourself&mldr;<ul><li>Does the code meet current requirements?</li><li>Are there frequent or sever production issues?</li><li>How healthy are the dependencies?</li></ul></li><li>Lets say you choose &ldquo;evolve,&rdquo; what should you do?<ul><li>Automated tests with good coverage.</li><li>Upgrade/Replace outdated dependencies.</li><li>Use a linter and/or <code>black</code> for code formatting.</li><li>Use <code>pre-commit</code> for cross-team consistency.</li><li>Make sure current devs understand the story of the code.</li><li>Help future devs by writing detailed commit messages along with an issue tracker.</li><li>Document!</li><li>Build a culture of leaving clues for the future!</li></ul></li></ul><h2 id=day-2>Day 2</h2><h3 id=keeping-track-of-architectural-ish-decisions-in-a-sustainable-way>Keeping track of architectural-ish decisions in a sustainable way</h3><ul><li>The Problem<ul><li><strong>Is there a problem?</strong> Image a new coworker asks why a particular decision was made, but no one knows. We lose relevant information of the decision making process (e.g. context and alternatives considered).</li><li><strong>Why is this a problem?</strong> We cannot reliably reflect on our decisions, onboard new people, or evolve.</li><li><strong>What&rsquo;s causing this?</strong> Perhaps our tools are not specifically designed to capture changes, nor why they changed.</li></ul></li><li>Architectural Decisions: The thing we need to capture.<ul><li><strong>Architectural Decisions (AD)</strong>: A software design choice&mldr;that is architecturally significant. It&rsquo;s an AD if you need to ask:<ul><li>Should we meet to discuss this?</li><li>What framework should we use?</li><li>Could we use [shiny-new-thing] for this?</li></ul></li><li><strong>Architecturally Significant Requirement (ASR)</strong>: A requirement that has a measurable effect.</li></ul></li><li><a href=https://cognitect.com/blog/2011/11/15/documenting-architecture-decisions>Architectural Decision Record</a> (ADR) [<a href=https://18f.gsa.gov/2021/07/06/architecture_decision_records_helpful_now_invaluable_later/>also</a>]: The tool we can use to capture.<ul><li><strong>What is an ADR?</strong> A short, practical to fill, text file describing a specific AD. Like a journal entry to future developers.</li><li><strong>Who is it for?</strong> Primarily for developers and technology staff.</li><li><strong>What&rsquo;s in it?</strong>:<ul><li>Context: Why did this need to happen? What need to be considered?</li><li>Options: What were the options? What were the pros/cons of each?</li><li>Consequences: What will happen as a result?</li><li>Status: Has the decision been implemented or superseded?</li></ul></li><li><strong>Where does it live?</strong> Close to code (benefits from peer reviewing and discoverability), wiki, or something else.</li></ul></li><li>Takeaways:<ul><li>Leads teams to consensus.</li><li>Prevents knowledge hoarding.</li><li>Gets new maintainers up to speed.</li><li>Not one person with critical knowledge.</li><li>Shows maintainers if a change they&rsquo;d like to do has been considered previously.</li><li>Can be used as justification to stakeholders.</li></ul></li></ul><h3 id=django-migrations-pitfalls-and-solutions>Django Migrations: Pitfalls and Solutions</h3><ul><li>Migrations and Branches<ul><li>Rewinding migrations only works if the relevant migration files are in the codebase, regardless of applied migrations.</li><li>This can cause problems when switching branches with divergent migrations. Solutions:<ul><li>Reverse migrations before switching branches.</li><li>Restore a backup from before you ran either branch&rsquo;s migrations.</li><li>Use backward compatible migrations.</li></ul></li><li>A similar problem occurs when trying to merge two branches with divergent migrations. Solution:<ul><li><code>python manage.py makemigration -merge</code></li></ul></li></ul></li><li>Reversible Migrations<ul><li>Migrations are not time travel&mldr;database backups are!</li><li>Common rewind errors include, using <code>RunPython</code> with no reverse function, removing a constraint if data has been added that violates that constraint, or deleting a field that is non-null and has no default.</li><li>You can improve reversibility by backing up your database, set fields as nullable for some time before deleting them, and using a reverse function with <code>RunPython</code> (or at least use <code>noop</code>).</li></ul></li><li>Backwards Compatible Migrations<ul><li>The Deployment Race Condition: When, during deployment, the codebase and database will be out of sync! This can cause errors on your site if a request comes in while they are out of sync.</li><li>Assuming you are adding to the database more often than removing, you can reduce the frequency of this issue by migrating the database first, then deploying your new code.</li><li>For all other cases, you should try to create backwards compatible migration, i.e. migrations that once applied still work with you old code before that it gets updated.</li><li>Some migrations trivially backwards compatible:<ul><li>Ops with no DB schema change (RunPython, changing choices, squashing migrations, etc.)</li><li>Adding a nullable field.</li><li>Adding a model.</li><li>Removing/Relaxing a constraint.</li><li>Adding a constraint that all existing data/code already meets.</li><li>Removing a model that isn&rsquo;t referenced.</li></ul></li><li>Others, are not. For those, we want to try and get those to &ldquo;look&rdquo; like the above list.<ul><li>You can make some migration noops by using legacy database names.<ul><li>To rename a field, set <code>db_column</code> to the old name, and django will not update the database.</li><li>To rename a model, set <code>db_table</code> to old name, and django will not update the database.</li><li>You can even move models between apps an avoid schema changes by using <code>db_table</code> and <code>SperateDatabaseAndState</code>.</li></ul></li><li>You can decompose some migrations into two deploys.<ul><li>Adding a constraint: First deploy code that satisfies constraint, then deploy migration to update data.</li><li>Removing a model: First deploy code that remove all references, then deploy migration to remove the model.</li><li>Remove a field: First deploy code that deprecates the field using <code>django-deprecate-fields</code> and remove all code references, then deploy migration to remove the field.</li></ul></li><li>For all other, more complicated, cases, use scheduled downtime (maintenance mode).<ul><li>Split/Merge fields/models.</li><li>Change field types.</li><li>Do &ldquo;true&rdquo; field/model renames.</li><li>Compress multiple releases into one.</li></ul></li></ul></li></ul></li><li>Failed Migrations<ul><li>If your migrations fail, be aware that:<ul><li>You should abort your deployment.</li><li>Each migration is atomic, but the group of them are not.</li><li>If your migrations are not backwards compatible, your users will be getting errors (unless you are in maintenance mode).</li><li>If your migrations are not backwards compatible, your database will be in an incompatible state, and you can&rsquo;t use <code>manage.py shell</code>.</li></ul></li><li>To fix this:<ul><li>Avoid this to begin with by testing against production data!</li><li>Correct data with <code>manage.py shell</code>, assuming your migrations were backwards compatible.</li><li>Push the broken migration onto the server (because you should have aborted the deployment), and reverse them (assuming they were reversible).</li><li>Restore database to a backup.</li><li><code>manage.py dbshell</code></li></ul></li></ul></li></ul><h3 id=django-through-the-years>Django Through the Years</h3><p>Not much to say about this, other than it was a very fun history lesson! ❤️</p><h3 id=just-enough-ops-for-developers>Just enough ops for developers</h3><p>My main takeaway here was the following <a href=https://fastapi.tiangolo.com/async/>fastapi analogy</a>:</p><ul><li>CPU = Cook</li><li>Process = Cashier</li><li>Request = Customer</li></ul><h3 id=your-first-deployment-shouldnt-be-so-hard>Your First Deployment Shouldn&rsquo;t Be So Hard!</h3><p>Django is great, until you get to deployment, at which point there are a billion different ways to do it. This can be a barrier to entry for new developers and for experienced developers who need to prototype rapidly&mldr;enter <code>django-simple-deploy</code>.</p><p>Prerequisites:</p><ul><li>A simple Django project.</li><li>Use requirements.txt, Poetry, or Pipenv.</li><li>Use Git.</li><li>Have the target platform&rsquo;s CLI installed with an active account.</li></ul><pre tabindex=0><code>$ pip install django-simple-deploy
# Add simple deploy to INSTALLED APPS.
$ manage.py simple_deploy --platform fly_io --automate-all
# Profit!
</code></pre><h2 id=day-3>Day 3</h2><h3 id=async-django-the-practical-guide-youve-been-awaiting-for>Async Django: The practical guide you&rsquo;ve been awaiting for.</h3><ul><li><p>Async is exciting, but be aware that using async will make your application more complex.</p></li><li><p><code>import asyncio</code>: Python&rsquo;s implementation of an async runtime that Django uses.</p><pre tabindex=0><code>import asyncio
async def foo():
  ...
  await bar()

async def main():
  tasks = [asyncio.create_task(foo()) for range(5)]
  # Important! Wait for all tasks to complete.
  await asyncio.gather(*tasks)

asyncio.run(main())
</code></pre></li><li><p>Can you use this for background tasks?</p><ul><li>Kind off&mldr;if it fails, there is no built-in statuses, retires, or error handling.</li><li>It depends&mldr;on how you are running Django (WSGI or ASGI). With WSGI, hitting an async view spins up an event loop, but will disappear when then view exits (like the example above).</li></ul></li><li><p>Aggregate Views (what you did before GraphQL):</p><pre tabindex=0><code>import httpx
import asyncio

async def aggregate_view(): # pseudo code
  async with httpx.AsyncClient() as client:
    response_a, response_b = asyncio.gather(
      client.get(view_a_url),
      client.get(view_b_url),
    )
  return JsonResponse({
    &#39;response_a&#39;: response_a.json(),
    &#39;response_b&#39;: response_b.json(),
  })
</code></pre></li><li><p>Chat App (four ways):</p><ul><li>Polling (HTMX): Simple, but doesn&rsquo;t scale, isn&rsquo;t responsive, and can lead to self DDOS.</li><li>Long Polling (HTMX + Channels): Responsiveness, but creates a lot connections.</li><li>Server-Sent Events (HTMX + Channels): Better, keeps the connection open.</li><li>WebSockets (HTMX + Channels): Also keeps the connection open, but allows two-way communication.</li></ul></li></ul><h3 id=why-large-django-projects-need-a-data-prefetching-layer>Why large Django projects need a data (prefetching) layer</h3><ul><li><p>&ldquo;DRY isn&rsquo;t helpful if you need to be careful.&rdquo;</p></li><li><p>Django REST Framework loves DRY, but has high change amplification as a side effect.</p></li><li><p>Change Amplification: The expected number of places in the codebase that needs to be modified during an atomic change to the software.</p></li><li><p>An example of this in DRF is needing to prefetch in serializers.</p><pre tabindex=0><code>class MovieSerializer(ModelSerializer):
  # data that requires prefetching

# You have to remeber to prefetch for each view using MovieSerializer.
class MovieListView(ListAPIView):
  queryset = Movie.objects.prefetch_related(&#34;directors&#34;)
  serializer_class = MovieSerializer

class MovieDetailView(ListAPIView):
  queryset = Movie.objects.prefetch_related(&#34;directors&#34;)
  serializer_class = MovieSerializer
</code></pre></li><li><p>You could do one of two things to combat this:</p><ol><li>Use non-DRF serializers that are very <strong>explicit</strong> about prefetching.</li></ol><ul><li><code>django-virtual-models</code>.</li></ul><ol start=2><li>Or keep DRF, but:</li></ol><ul><li>Warn about missing prefetches for each serializer.</li><li>Automatically run necessary prefetches.</li><li>Automatically prevent unnecessary ones.</li><li>Keep serializer nesting support.</li><li>Keep <code>SerializerMethodField</code> support.</li></ul></li><li><p>TLDR: Use tools to be <strong>explicit</strong> about the data you expect from the DB. Otherwise you&rsquo;ll suffer from performance regressions and your read logic will break frequently.</p></li></ul><h3 id=a-pythonic-full-text-search>A pythonic full-text search</h3><ul><li>PostgreSQL added full text search in 2008.</li><li>Django added <a href=https://docs.djangoproject.com/en/4.1/ref/contrib/postgres/search/>full text search</a> in 2016.</li><li>Paolo has a <a href=https://www.paulox.net/2017/12/22/full-text-search-in-django-with-postgresql/>great article</a> outlining the various search features.</li></ul><h3 id=home-on-the-range-with-django---getting-comfortable-with-ranges-and-range-fields>Home on the range with Django - getting comfortable with ranges and range fields</h3><ul><li>Ranges are everywhere!</li><li>Support for <a href=https://docs.djangoproject.com/en/4.1/ref/contrib/postgres/fields/#range-fields>ranges</a> was added for PostgreSQL Django in 2015.</li><li>The typical approach is to us &ldquo;start&rdquo; and &ldquo;stop&rdquo; fields, but that gets complicated fast.<ul><li>The DB doesn&rsquo;t know these two fields are related.</li><li>You have to manually add bounding/validation/constraint logic.</li><li>Queries can get weird/complicated.</li></ul></li><li>Ranges fix all this!<ul><li>1 field that stores lower, upper, and boundary information.</li><li>Automatically validates/constrains values.</li><li>Easy/Intuitive queries.</li></ul></li><li>Ranges (Math):<ul><li>Ranges = Intervals, Inclusive = Closed, Exclusive = Open</li><li>(exclusive, exclusive) - (1, 3) - 2</li><li>[inclusive, exclusive) - [1, 3) - 1, 2 <code>The default for Django ranges!</code></li><li>(exclusive, inclusive] - (1, 3] - 2, 3</li><li>[inclusive, inclusive] - [1, 3] - 1, 2, 3</li></ul></li><li>There are lots of very useful query filters!<ul><li><code>__overlap</code>, <code>__contains</code>, <code>__adjacent_to</code>, <code>__fully_lt/gt</code>, etc.</li></ul></li><li>Django supports a number of different value types via <code>pysycopg2.extra</code>.<ul><li>You can also create custom types! Example: IP ranges!</li></ul></li><li>Pitfalls<ul><li>Limited Django Admin support.</li><li>You have to use <code>Cast</code> when using <code>F()</code>.</li><li>You have to use <code>Lower</code> and <code>Upper</code> database functions to access values.</li></ul></li><li>Resources<ul><li><code>psycopg2.extras</code></li><li><code>django-range-merge</code></li><li><code>django-generate-series</code></li></ul></li></ul><a href="mailto: reply@djpeacher.com?subject=RE: DjangoCon%20US%202022">Reply via email</a></main><footer style=border:none></footer></body></html>